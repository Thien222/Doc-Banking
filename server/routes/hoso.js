const express = require('express');
const router = express.Router();
const HoSo = require('../models/HoSo');
const { notifyNewHoso, notifyBanGiao, notifyTuChoi, notifyHoanTra, notifyCompleted, notifyNhanBanGiao, notifyNhanChungTu, notifyEditHoso, notifyDeleteHoso } = require('../utils/notifications');

// L·∫•y th·ªëng k√™ t·ªïng quan
router.get('/stats', async (req, res) => {
  try {
    const total = await HoSo.countDocuments();
    const processing = await HoSo.countDocuments({ 
      trangThai: { 
        $in: ['moi', 'dang-xu-ly', 'qttd-da-nhan', 'qttd-hoan-tra'] 
      } 
    });
    const completed = await HoSo.countDocuments({ 
      trangThai: { 
        $in: ['hoan-tat', 'hoan-thanh'] 
      } 
    });
    
    res.json({
      success: true,
      data: {
        total,
        processing,
        completed
      }
    });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// L·∫•y danh s√°ch h·ªì s∆° (c√≥ filter, ph√¢n trang)
// GET /hoso - L·∫•y danh s√°ch h·ªì s∆° v·ªõi filter
router.get('/', async (req, res) => {
  try {
    console.log('üìã [HOSO] GET request query:', req.query);
    
    const {
      page = 1,
      limit = 10,
      soTaiKhoan,
      tenKhachHang,
      trangThai,
      phong,
      qlkh,
      fromDate,
      toDate
    } = req.query;

    // Normalize possible array params (when sent both in URL and params)
    const pickFirst = v => Array.isArray(v) ? v[0] : v;
    const soTaiKhoanS = pickFirst(soTaiKhoan);
    const tenKhachHangS = pickFirst(tenKhachHang);
    const trangThaiS = pickFirst(trangThai);
    const phongS = pickFirst(phong);
    const qlkhS = pickFirst(qlkh);
    const fromDateS = pickFirst(fromDate);
    const toDateS = pickFirst(toDate);

    // Build filter object
    const filter = {};
    
    if (typeof soTaiKhoanS === 'string' && soTaiKhoanS.trim()) {
      filter.soTaiKhoan = { $regex: soTaiKhoanS.trim(), $options: 'i' };
    }
    
    if (typeof tenKhachHangS === 'string' && tenKhachHangS.trim()) {
      filter.tenKhachHang = { $regex: tenKhachHangS.trim(), $options: 'i' };
    }
    
    if (typeof trangThaiS === 'string' && trangThaiS.trim()) {
      filter.trangThai = trangThaiS.trim();
    }
    
    if (typeof phongS === 'string' && phongS.trim()) {
      filter.phong = { $regex: phongS.trim(), $options: 'i' };
    }
    
    if (typeof qlkhS === 'string' && qlkhS.trim()) {
      filter.qlkh = { $regex: qlkhS.trim(), $options: 'i' };
    }

    // S·ª¨A: X·ª≠ l√Ω date filter ƒë√∫ng c√°ch
    if (fromDateS || toDateS) {
      filter.ngayGiaiNgan = {};
      
      if (typeof fromDateS === 'string' && fromDateS.trim()) {
        try {
          const from = new Date(fromDateS.trim());
          if (!isNaN(from.getTime())) {
            // Set to start of day
            from.setHours(0, 0, 0, 0);
            filter.ngayGiaiNgan.$gte = from;
            console.log('üìÖ [HOSO] FromDate filter:', from);
          } else {
            console.warn('‚ö†Ô∏è [HOSO] Invalid fromDate:', fromDateS);
          }
        } catch (err) {
          console.warn('‚ö†Ô∏è [HOSO] Error parsing fromDate:', fromDateS, err.message);
        }
      }
      
      if (typeof toDateS === 'string' && toDateS.trim()) {
        try {
          const to = new Date(toDateS.trim());
          if (!isNaN(to.getTime())) {
            // Set to end of day
            to.setHours(23, 59, 59, 999);
            filter.ngayGiaiNgan.$lte = to;
            console.log('üìÖ [HOSO] ToDate filter:', to);
          } else {
            console.warn('‚ö†Ô∏è [HOSO] Invalid toDate:', toDateS);
          }
        } catch (err) {
          console.warn('‚ö†Ô∏è [HOSO] Error parsing toDate:', toDateS, err.message);
        }
      }
      
      // N·∫øu kh√¥ng c√≥ date filter h·ª£p l·ªá n√†o, x√≥a filter ngayGiaiNgan
      if (Object.keys(filter.ngayGiaiNgan).length === 0) {
        delete filter.ngayGiaiNgan;
      }
    }

    console.log('üîç [HOSO] Final filter:', JSON.stringify(filter, null, 2));

    // Execute query with pagination
    const pageNum = parseInt(page, 10) || 1;
    const limitNum = parseInt(limit, 10) || 10;
    const skip = (pageNum - 1) * limitNum;

    const [data, total] = await Promise.all([
      HoSo.find(filter)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum)
        .lean(), // S·ª¨A: D√πng lean() ƒë·ªÉ tƒÉng performance
      HoSo.countDocuments(filter)
    ]);

    console.log(`üìä [HOSO] Found ${total} records, returning ${data.length} items for page ${pageNum}`);

    res.json({
      success: true,
      data: data,
      total,
      page: pageNum,
      totalPages: Math.ceil(total / limitNum)
    });

  } catch (error) {
    console.error('‚ùå [HOSO] GET Error:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói t·∫£i h·ªì s∆°: ' + error.message
    });
  }
});

// Endpoint test: tr·∫£ v·ªÅ to√†n b·ªô h·ªì s∆° kh√¥ng filter g√¨
router.get('/all', async (req, res) => {
  try {
    const data = await HoSo.find({}).sort({ createdAt: -1 });
    res.json({ data });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Test route to check backend health
router.get('/test', async (req, res) => {
  try {
    const count = await HoSo.countDocuments();
    res.json({ 
      message: 'Hoso backend is working', 
      totalRecords: count,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Clean up invalid dates in database (ADMIN ONLY)
router.post('/cleanup-dates', async (req, res) => {
  try {
    console.log('üßπ [CLEANUP] Starting date cleanup...');
    
    // Find records with invalid dates
    const invalidRecords = await HoSo.find({
      ngayGiaiNgan: { $type: "date" }
    });
    
    let cleanedCount = 0;
    for (const record of invalidRecords) {
      if (record.ngayGiaiNgan && isNaN(record.ngayGiaiNgan.getTime())) {
        await HoSo.findByIdAndUpdate(record._id, { 
          $unset: { ngayGiaiNgan: "" } 
        });
        cleanedCount++;
        console.log(`üßπ Cleaned invalid date for record: ${record.soTaiKhoan}`);
      }
    }
    
    console.log(`‚úÖ [CLEANUP] Completed. Cleaned ${cleanedCount} records.`);
    res.json({ 
      success: true, 
      message: `Cleaned up ${cleanedCount} invalid dates`,
      cleanedCount 
    });
  } catch (err) {
    console.error('‚ùå [CLEANUP] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// POST /hoso - T·∫°o h·ªì s∆° m·ªõi
router.post('/', async (req, res) => {
  try {
    console.log('‚ûï [HOSO] POST request body:', req.body);

    const hosoData = { ...req.body };

    // S·ª¨A: Check cho "Invalid Date" string t·ª´ client
    if (hosoData.ngayGiaiNgan === 'Invalid Date') {
      console.warn('‚ö†Ô∏è [HOSO] Client sent Invalid Date string');
      delete hosoData.ngayGiaiNgan;
    }

    // S·ª¨A: X·ª≠ l√Ω ngayGiaiNgan ƒë√∫ng c√°ch
    if (hosoData.ngayGiaiNgan) {
      if (typeof hosoData.ngayGiaiNgan === 'string') {
        const date = new Date(hosoData.ngayGiaiNgan);
        if (isNaN(date.getTime())) {
          console.warn('‚ö†Ô∏è [HOSO] Invalid ngayGiaiNgan string:', hosoData.ngayGiaiNgan);
          delete hosoData.ngayGiaiNgan; // X√≥a n·∫øu kh√¥ng h·ª£p l·ªá
        } else {
          hosoData.ngayGiaiNgan = date;
          console.log('üìÖ [HOSO] Parsed ngayGiaiNgan:', date);
        }
      } else if (hosoData.ngayGiaiNgan instanceof Date) {
        if (isNaN(hosoData.ngayGiaiNgan.getTime())) {
          console.warn('‚ö†Ô∏è [HOSO] Invalid ngayGiaiNgan Date object');
          delete hosoData.ngayGiaiNgan;
        }
      }
    }

    // S·ª¨A: X·ª≠ l√Ω soTienGiaiNgan
    if (hosoData.soTienGiaiNgan) {
      const amount = Number(hosoData.soTienGiaiNgan);
      if (isNaN(amount)) {
        console.warn('‚ö†Ô∏è [HOSO] Invalid soTienGiaiNgan:', hosoData.soTienGiaiNgan);
        delete hosoData.soTienGiaiNgan;
      } else {
        hosoData.soTienGiaiNgan = amount;
      }
    }

    console.log('üíæ [HOSO] Creating with data:', JSON.stringify(hosoData, null, 2));

    const newHoSo = await HoSo.create(hosoData);
    console.log('‚úÖ [HOSO] Created successfully:', newHoSo._id);
    
    // G·ª≠i notification cho h·ªì s∆° m·ªõi
    try {
      console.log('üîî Sending notification for new h·ªì s∆°...');
      notifyNewHoso(newHoSo);
      console.log('‚úÖ Notification sent for new h·ªì s∆°');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }

    res.status(201).json({
      success: true,
      data: newHoSo,
      message: 'T·∫°o h·ªì s∆° th√†nh c√¥ng'
    });

  } catch (error) {
    console.error('‚ùå [HOSO] POST Error:', error);
    res.status(500).json({
      success: false,
      error: 'L·ªói t·∫°o h·ªì s∆°: ' + error.message
    });
  }
});

// S·ª≠a h·ªì s∆°
router.put('/:id', async (req, res) => {
  try {
    console.log('‚úèÔ∏è Editing h·ªì s∆°:', req.params.id, req.body);
    
    // S·ª¨A: Check cho "Invalid Date" string t·ª´ client
    const cleanData = { ...req.body };
    if (cleanData.ngayGiaiNgan === 'Invalid Date') {
      console.warn('‚ö†Ô∏è [HOSO] Client sent Invalid Date string in PUT');
      delete cleanData.ngayGiaiNgan;
    }
    
    // Clean up date fields
    if (cleanData.ngayGiaiNgan) {
      const date = new Date(cleanData.ngayGiaiNgan);
      if (isNaN(date.getTime())) {
        delete cleanData.ngayGiaiNgan; // Remove invalid dates
      } else {
        cleanData.ngayGiaiNgan = date;
      }
    }
    
    const updated = await HoSo.findByIdAndUpdate(req.params.id, cleanData, { new: true });
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    
    console.log('‚úÖ H·ªì s∆° ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t:', updated.soTaiKhoan);
    
    // G·ª≠i notification c·∫≠p nh·∫≠t h·ªì s∆°
    try {
      console.log('üîî Sending notification for h·ªì s∆° edit...');
      notifyEditHoso(updated, req.body.user || '');
      console.log('‚úÖ Notification sent for h·ªì s∆° edit');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    
    res.json(updated);
  } catch (err) {
    console.error('‚ùå Error editing h·ªì s∆°:', err);
    res.status(400).json({ error: err.message });
  }
});

// X√≥a h·ªì s∆°
router.delete('/:id', async (req, res) => {
  try {
    console.log('üóëÔ∏è Deleting h·ªì s∆°:', req.params.id);
    
    const deleted = await HoSo.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    
    console.log('‚úÖ H·ªì s∆° ƒë√£ ƒë∆∞·ª£c x√≥a:', deleted.soTaiKhoan);
    
    // G·ª≠i notification x√≥a h·ªì s∆°
    try {
      console.log('üîî Sending notification for h·ªì s∆° delete...');
      notifyDeleteHoso(deleted, req.body.user || '');
      console.log('‚úÖ Notification sent for h·ªì s∆° delete');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    
    res.json({ message: 'ƒê√£ x√≥a h·ªì s∆°' });
  } catch (err) {
    console.error('‚ùå Error deleting h·ªì s∆°:', err);
    res.status(400).json({ error: err.message });
  }
});

// B√†n giao h·ªì s∆° (BGD -> QTTD)
router.put('/:id/ban-giao', async (req, res) => {
  try {
    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'dang-xu-ly',
        'banGiao.daBanGiao': true,
        'banGiao.user': req.body.user,
        'banGiao.ghiChu': req.body.ghiChu || '',
        // ƒê·∫£m b·∫£o nhanGiao.daNhan l√† false ho·∫∑c undefined khi b√†n giao
        $unset: { 'nhanGiao.daNhan': '' }
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    // G·ª≠i notification cho b√†n giao h·ªì s∆°
    notifyBanGiao(updated, req.body.user);
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// L·∫•y danh s√°ch h·ªì s∆° ch·ªù QTTD nh·∫≠n
router.get('/cho-qttd-nhan', async (req, res) => {
  try {
    // C√≥ th·ªÉ d√πng tr·∫°ng th√°i 'cho-qttd-nhan' ho·∫∑c 'dang-xu-ly' t√πy quy ∆∞·ªõc
    const data = await HoSo.find({ trangThai: 'dang-xu-ly', 'banGiao.daBanGiao': true, 'nhanGiao.daNhan': { $ne: true } }).sort({ createdAt: -1 });
    res.json(data);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// L·∫•y danh s√°ch h·ªì s∆° ch·ªù QLKH nh·∫≠n ch·ª©ng t·ª´
router.get('/cho-qlkh-nhan-chung-tu', async (req, res) => {
  try {
    const data = await HoSo.find({ 
      trangThai: 'qttd-hoan-tra', 
      'hoanTra.daHoanTra': true, 
      'nhanChungTu.daNhan': { $ne: true } 
    }).sort({ createdAt: -1 });
    res.json(data);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// QTTD x√°c nh·∫≠n nh·∫≠n h·ªì s∆°
router.post('/:id/nhan', async (req, res) => {
  try {
    console.log('‚úÖ QTTD nh·∫≠n b√†n giao h·ªì s∆°:', req.params.id, req.body);
    
    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'qttd-da-nhan',
        'nhanGiao.daNhan': true,
        'nhanGiao.user': req.body.user || '',
        'nhanGiao.ghiChu': req.body.ghiChu || ''
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    
    console.log('‚úÖ H·ªì s∆° ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr·∫°ng th√°i:', updated.trangThai);
    
    // G·ª≠i notification cho QTTD nh·∫≠n b√†n giao
    try {
      console.log('üîî Sending notification for QTTD nhan ban giao...');
    notifyNhanBanGiao(updated, req.body.user || '');
      console.log('‚úÖ Notification sent for QTTD nhan ban giao');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    
    res.json(updated);
  } catch (err) {
    console.error('‚ùå Error in QTTD nhan ban giao:', err);
    res.status(400).json({ error: err.message });
  }
});

// BGD t·ª´ ch·ªëi h·ªì s∆°
router.post('/:id/bgd-tu-choi', async (req, res) => {
  try {
    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'bgd-tu-choi',
        'bgdTuChoi.daTuChoi': true,
        'bgdTuChoi.user': req.body.user || '',
        'bgdTuChoi.lyDo': req.body.lyDo || ''
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    
    // G·ª≠i notification cho t·ª´ ch·ªëi h·ªì s∆°
    try {
      notifyTuChoi(updated, req.body.user || '', req.body.lyDo || '', 'ban-giam-doc');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// QTTD t·ª´ ch·ªëi nh·∫≠n h·ªì s∆°
router.post('/:id/qttd-tu-choi', async (req, res) => {
  try {

    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'qttd-tu-choi',
        'qttdTuChoi.daTuChoi': true,
        'qttdTuChoi.user': req.body.user || '',
        'qttdTuChoi.lyDo': req.body.lyDo || ''
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    // G·ª≠i notification cho t·ª´ ch·ªëi h·ªì s∆°
    try {
      notifyTuChoi(updated, req.body.user || '', req.body.lyDo || '', 'quan-tri-tin-dung');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// QTTD ho√†n tr·∫£ h·ªì s∆° v·ªÅ QLKH
router.post('/:id/hoan-tra', async (req, res) => {
  try {
    const before = await HoSo.findById(req.params.id);
    if (!before) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    // Ch·ªâ update c√°c tr∆∞·ªùng tr·∫°ng th√°i, gi·ªØ nguy√™n m·ªçi tr∆∞·ªùng kh√°c
    before.trangThai = 'qttd-hoan-tra';
    before.hoanTra = {
      daHoanTra: true,
      user: req.body.user || '',
      ghiChu: req.body.note || ''
    };
    await before.save();
    // G·ª≠i notification cho ho√†n tr·∫£ h·ªì s∆°
    try {
      notifyHoanTra(before, req.body.user || '');
    } catch (notifErr) {
      console.error('‚ùå Error sending notification:', notifErr);
    }
    res.json(before);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// QLKH x√°c nh·∫≠n ƒë√£ nh·∫≠n ƒë·ªß ch·ª©ng t·ª´
router.post('/:id/xac-nhan-nhan-chung-tu', async (req, res) => {
  try {
    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'hoan-tat', // ho·∫∑c 'qlkh-da-nhan'
        'nhanChungTu.daNhan': true,
        'nhanChungTu.user': req.body.user || '',
        'nhanChungTu.ghiChu': req.body.note || ''
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    
    // G·ª≠i notification cho QLKH nh·∫≠n ch·ª©ng t·ª´
    notifyNhanChungTu(updated, req.body.user || '');
    
    // G·ª≠i notification cho ho√†n th√†nh h·ªì s∆°
    notifyCompleted(updated, req.body.user || '');
    
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// QLKH t·ª´ ch·ªëi nh·∫≠n ch·ª©ng t·ª´
router.post('/:id/tu-choi-nhan-chung-tu', async (req, res) => {
  try {
    const updated = await HoSo.findByIdAndUpdate(
      req.params.id,
      {
        trangThai: 'qlkh-tu-choi-nhan',
        'nhanChungTu.daNhan': false,
        'nhanChungTu.user': req.body.user || '',
        'nhanChungTu.ghiChu': req.body.note || ''
      },
      { new: true }
    );
    if (!updated) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' });
    // G·ª≠i notification cho QLKH t·ª´ ch·ªëi nh·∫≠n ch·ª©ng t·ª´
    try { require('../utils/notifications').sendNotification(['admin', 'ban-giam-doc', 'quan-tri-tin-dung'], { type: 'qlkh_tu_choi_nhan_chung_tu', title: 'QLKH t·ª´ ch·ªëi nh·∫≠n ch·ª©ng t·ª´', message: `QLKH ƒë√£ t·ª´ ch·ªëi nh·∫≠n ch·ª©ng t·ª´ h·ªì s∆° ${updated.soTaiKhoan}`, data: { hosoId: updated._id } }); } catch(e){}
    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});


module.exports = router; 

